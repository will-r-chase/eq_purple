<!DOCTYPE html>
<html>

<head>
  <meta charset='utf-8' />
  <title>Remote Triggering of Earthquakes</title>
  <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
  <script src="https://unpkg.com/deck.gl@latest/dist.min.js"></script>
  <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v1.1.0-beta.1/mapbox-gl.js"></script>
  <link rel="stylesheet" type="text/css" href="https://api.tiles.mapbox.com/mapbox-gl-js/v1.1.0-beta.1/mapbox-gl.css">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/d3-scale-radial.js"></script>
  <script src="https://unpkg.com/intersection-observer@0.5.1/intersection-observer.js"></script>
  <script src="https://unpkg.com/scrollama"></script>
  <link href="https://fonts.googleapis.com/css?family=Alegreya|Alegreya+SC|Raleway|Source+Sans+Pro&display=swap" rel="stylesheet">

  <style media="screen">
    body {
      margin: 0;
      padding: 0;
    }

    html {
      font-size: 2.4vw;
      -webkit-font-feature-settings: 'lnum'1;
      font-feature-settings: 'lnum'1;
    }

    @media all and (min-width:1000px) {
      html {
        font-size: 20px;
      }
    }

    @media (min-width: 320px) and (max-width: 520px) {
      html {
        font-size: 16px;
      }
    }

    #map {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 100%;
    }

    svg {
      position: absolute;
      width: 100%;
      height: 100%;
    }

    circle {
      stroke-width: 0;
    }

    section {
      padding: 500px 25px 500px 25px;
      line-height: 1.2rem;
      margin: 500px 25px 500px 25px;
      opacity: 0.15;
      font-size: 1rem;
      color: #2A2A2A;
      background-color: rgba(0, 0, 0, 0);
    }

    section p {
      background-color: #fafafa;
      padding: 15px;
    }

    section.active {
      opacity: 0.9;
    }

    section:last-child {
      border-bottom: none;
      margin-bottom: 300px;
    }

    .features {
      width: 600px;
      margin-right: auto;
      margin-left: auto;
      font-family: 'Alegreya', serif;
      font-size: 1rem;
      line-height: 1.35;
      overflow-y: scroll;
      background-color: rgba(0, 0, 0, 0);
      color: #2A2A2A;
    }

    h3 {
      font-family: 'Alegreya SC', serif;
      font-size: 1.4rem;
      color: #2A2A2A;
    }

    .myArrow,
    #arrowhead {
      fill: none;
      stroke: #7E7D7E;
    }

    .bar-arrow,
    #arrowhead {
      fill: none;
      stroke: #7E7D7E;
    }

    .bar-chart {
      fill: #872B32; //#aa0303
      stroke: none;
    }

    circle.bar-axis {
      font-family: 'Source Sans Pro', sans-serif;
      fill: none;
      stroke: #1E1E1E;
      stroke-opacity: 0.7;
      stroke-width: 0.5px;
      stroke-dasharray: 2;
    }

    .chart-axis {
      font-family: 'Source Sans Pro', sans-serif;
    }

    .chart-label {
      font-family: 'Source Sans Pro', sans-serif;
      font-size: 0.8rem;
    }

    .mainshock-label {
      font-family: 'Source Sans Pro', sans-serif;
    }

    .bar-label {
      font-family: 'Source Sans Pro', sans-serif;
    }

    .bar-axis {
      font-family: 'Source Sans Pro', sans-serif;
    }

    .modal-window {
      position: fixed;
      background-color: rgba(230, 230, 230, 0.5);
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      z-index: 999;
      opacity: 0;
      pointer-events: none;
      -webkit-transition: all 0.3s;
      -moz-transition: all 0.3s;
      transition: all 0.3s;
    }

    .modal-window:target {
      opacity: 1;
      pointer-events: auto;
    }

    .modal-window>div {
      font-family: 'Alegreya', serif;
      font-size: 0.9rem;
      width: 400px;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 2em;
      background: #fafafa;
      border-left: 3px solid #E3191C;
    }

    .modal-close {
      font-family: 'Alegreya', serif;
      color: #aaa;
      line-height: 1.2;
      font-size: 0.7rem;
      position: absolute;
      right: 0;
      text-align: right;
      top: 0;
      width: 70px;
      text-decoration: none;
      padding: 10px;
    }

    .modal-close:hover {
      color: black;
    }

    .btn {
      position: relative;
      z-index: 1000;
      font-family: 'Alegreya SC', serif;
      letter-spacing: 0.05em;
      text-decoration: none;
      background-color: #fafafa;
      color: #872B32;
    }

    .container {
      display: grid;
      justify-content: center;
      align-items: center;
      /* height: 100vh; */
    }

    #intro {
      background:
        linear-gradient(to left,
          rgba(0, 0, 0, 0),
          rgba(0, 0, 0, 0.7)),
        url(chile_eq.jpg);
      -webkit-background-size: cover;
      -moz-background-size: cover;
      -o-background-size: cover;
      background-size: cover;
      font-family: 'Raleway', sans-serif;
      height: 100vh;
      position: relative;
      padding-top: 1%;
      padding-left: 5%;
      padding-right: 5% padding-bottom: 1%;
      color: #fafafa;
      /* background: #fafafa; */
      opacity: 1;
      z-index: 2;
    }

    #footer {
      font-family: 'Alegreya', serif;
      font-size: 1rem;
      height: 200vh;
      position: relative;
      padding-top: 1%;
      padding-left: 5%;
      padding-right: 5%;
      padding-bottom: 1%;
      background: #fafafa;
      opacity: 1;
      z-index: 2;
    }

    #outro {
      box-sizing: border-box;
      padding-left: 25vw;
      padding-right: 25vw;
    }

    #methods {
      box-sizing: border-box;
      padding: 25px;
      border-style: dotted;
      border-width: 2px;
      margin-left: 25vw;
      margin-right: 25vw;
      margin-top: 100px;
      color: #2A2A2A;
    }

    #methods-title {
      font-family: 'Alegreya SC', serif;
      font-size: 1.2rem;
      letter-spacing: 0.08em;
      color: #000;
    }

    .main {
      position: relative;
      z-index: 1;
    }

    .sticky {
      position: -webkit-sticky;
      position: sticky;
      top: 0;
    }

    .title {
      margin-top: 7vh;
      font-size: 2rem;
      line-height: 1.45em;
      letter-spacing: 0.1em;
    }

    .xtra-big {
      font-size: 3rem;
      font-weight: 800;
      line-height: 1.5em;
    }

    .small {
      margin-top: 15vh;
      font-size: 1rem;
      font-weight: lighter;
    }

    .modal-title {
      font-family: 'Alegreya SC', serif;
      font-size: 1.15rem;
      margin-bottom: 10px;
      letter-spacing: 0.08em;
      color: #000;
    }

    .mobile {
      position: relative;
      padding: 5%;
      width: 80%;
      margin-left: 10%;
      margin-top: 50%;
      font-family: 'Raleway', sans-serif;
      font-size: 30px;

    }

    .scroll {
      background-image: url(arrow_white.png);
      background-size: cover;
      background-repeat: no-repeat;
      margin-left: auto;
      margin-right: auto;
      width: 85px;
      height: 85px;
    }

    .center {
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 10px;
      text-align: center;
      letter-spacing: 0.15em;
      font-size: 0.65rem;
      font-family: 'Raleway', sans-serif;
    }

    @media (min-width: 320px) and (max-width: 520px) {
      #map {
        position: fixed;
        left: 0;
        top: 0;
        bottom: 0;
        width: 100%;
        height: 50%;
      }

      section {
        padding: 400px 10px 400px 10px;
        margin: 400px 0px 400px 0px;
      }

      section p {
        padding: 10px;
      }

      .features {
        width: 300px;
        margin-right: auto;
        margin-left: auto;
      }

      .modal-window>div {
        width: 300px;
      }

      #footer {
        height: 400vh;
        padding-top: 1%;
        padding-left: 5%;
        padding-right: 5%;
        padding-bottom: 1%;
      }

      #outro {
        padding-left: 10px;
        padding-right: 10px;
      }

      #methods {
        padding: 5px;
        border-width: 2px;
        margin-left: 10px;
        margin-right: 10px;
        margin-top: 100px;
      }
    }
  </style>
</head>

<body>
  <div id="intro">
    <div class="title">
      <div class="xtra-big">CAN ONE</br>
        EARTHQUAKE</br></div>
      <div class="small">TRIGGER ANOTHER</br></div>
      ON THE</br>
      OTHER SIDE OF</br>
      THE WORLD?</br>
    </div>
    </br></br></br></br>
    </br>
    <h2>by Will Chase</h2></br>
    <div class="center">SCROLL</div>
    <div class="scroll"></div>

  </div>
  <div class="main">
    <div id="map"></div>
    <div class="container">
      <div id="welcome-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">Hello, this is an info box!</div>
          <div>Whenever you see something that <span class="btn">looks like this</span>, click it to open a
            popup that will contain explanations of jargon or helpful info. For example,
            did you know you can click on the ‘close’ button in the top left of this box to close it?
            See, I told you, helpful!</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="mag-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">magnitude</div>
          <div>Magnitude refers to the strength of an earthquake. Magnitude is reported on the Richter Magnitude Scale
            which ranges from 1 to 10 (M1.0–M10). Technically, today’s seismologists measure earthquakes with the Moment
            Magnitude Scale, but these values are converted to the Richter Scale for reporting to the public. The Richter
            Scale is logarithmic, meaning that each increase of one magnitude denotes a ten-fold increase in strength
            (ie. a M8.0 earthquake is 10 times stronger than a M7.0, or 1000 times stronger than a M5.0).
            Earthquakes M1.0–M5.0 are quite small, and rarely cause damage; M5.0 - M6.0 are moderate and may damage
            flimsy structures; M7.0–M9.0 are strong to catastrophic and can damage or entirely destroy structures. </div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="mainshock-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">mainshock</div>
          <div>The mainshock is the largest earthquake in a sequence. Earthquakes often occur in groups, with seismic activity
            over a short period of time. The mainshock is often proceeded be earthquakes (foreshocks), and almost always followed
            by earthquakes (aftershocks).</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="aftershock-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">aftershock</div>
          <div>Aftershocks are smaller earthquakes that follow in the same vicinity of a mainshock. Generally, aftershocks are
            limited to within two rupture lengths of the mainshock (the aftershock zone). Large mainshocks can be followed by thousands of aftershocks, which
            can be very large, but decay in strength and number over time.</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="triggered-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">remotely triggered earthquakes</div>
          <div>Remotely triggered earthquakes are earthquakes following a large mainshock that occur outside of the aftershock zone.
            As time and distance from the mainshock increase, it becomes more difficult to classify remotely triggered earthquakes.</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="seismograph-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">seismograph</div>
          <div>A seismograph is an instrument to detect movements in the earth’s crust. It generally consists of a measurement device
            attached to a recording device. Earthquakes are detected using networks of seismographs that are arrayed worldwide. These devices
            can be quite sensitive, but their ability to detect earthquakes depend on the proximity of the quake and the seismic noise in the region.</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="source-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">source event</div>
          <div>Source event refers to the earthquake that triggers another earthquake, used synonymously with mainshock.</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="strike-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">strike-slip earthquake</div>
          <div>Earthquakes occur at faults, which are zone of fracture between two blocks of rock. During an earthquake, the rock
            on one side slips relative to the other. The direction and type of slippage determines the type of earthquake. Faults where
            the rocks move upward or downward are called dip-slip. At strike-slip faults, blocks of rock move horizontally to each other. See <a class="btn"
              href="https://www.usgs.gov/faqs/what-a-fault-and-what-are-different-types?qt-news_science_products=0#qt-news_science_products" target="_blank">these animations from the USGS.</a></div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="waves-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">seismic waves</div>
          <div>When an earthquake strikes, it sends out energy in the form of seismic waves. Seismic waves come in two flavors:
            body waves, which move through the inside of the earth, and surface waves, which move along the surface of the earth. Within
            body waves, there are P waves, which move parallel to the wave direction, and S waves, which move perpendicular to the wave direction.
            Within surface waves there are Love waves, which cause the ground to move side-to-side, perpendicularly to the wave direction, and there are
            Rayleigh waves, which cause the ground to move up and down like rolling ocean waves. Of these classes, Love waves are especially
            destructive to structures.</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="antipode-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">antipode</div>
          <div>The antipode refers to the other side of the globe from a reference location. Imagine you were standing at some location
            on the earth. If you drilled a hole straight through the earth from that point, you would emerge at the antipode to your original location.</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="degrees-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">degrees</div>
          <div>This study sectioned the globe into discs of ten degrees in width and calculated the number of earthquakes in each slice as a rolling average. The values for the +/- five degree increments
            can then be tallied, which is what is represented by the bars in the circular plot. Degrees here refers to the angle around a circle (the globe).
            The study considers relative rates across 180 degrees on each side of a mainshock (adding up to 360 degrees, which encompases the whole globe).</div>
        </div>
      </div>
    </div>
    <div class="container">
      <div id="rate-modal" class="modal-window">
        <div>
          <a href="#close" title="Close" class="modal-close">Close</a>
          <div class="modal-title">relative rate</div>
          <div>The relative rate refers to the rate of earthquakes over the three days following a mainshock, compared to the historical average.
            A relative rate below one means fewer earthquakes occurred in this period than historically, whereas a relative rate above one indicates
            an increase in earthquakes.</div>
        </div>
      </div>
    </div>

    <div class='features'>
      <section id='welcome' class='step' step-num='1'>
        <p>Can one natural disaster influence the risk of another? It's well known that natural disasters
          can cause others in their immediate vicinity, for instance, hurricanes are often accompanied by flooding,
          and earthquakes are followed by aftershocks. But what about longer distance interactions? Could one earthquake
          trigger another on the other side of the world? <a class="btn" href="#welcome-modal">hey click me for more info!</a>
        </p>
      </section>
      <section id='section1' class='step' step-num='2'>

        <p>Our story begins in California in June of 1992. The dots below represent
          earthquakes recorded in the ten days from June 18th to June 28th. Their size and color correspond to their <a class="btn" href="#mag-modal">magnitude</a>:
          larger earthquakes are bigger and more red. There were 44 quakes during these ten days, though most were small
          and wouldn’t have been felt by people. But in the early hours of June 28th, that changed.</p>
      </section>
      <section id='section2' class='step' step-num='3'>

        <p>At 5:00 on the morning of June 28th, a magnitude 7.3 earthquake struck, waking much of
          Southern California. The epicenter was located near Landers California, in the Mojave Desert. Thanks
          to the remote location, the damage and loss of life was minimal.</p>
      </section>
      <section id='section3' class='step' step-num='4'>

        <p>As expected, the <a class="btn" href="#mainshock-modal">mainshock</a> was followed by a smattering of <a class="btn" href="#aftershock-modal">aftershocks</a> which occurred in the immediate vicinity
          of the mainshock, but what played out over the next ten days was entirely unexpected.</p>
      </section>
      <section id='section4' class='step' step-num='5'>

        <p>Survey stations across the Western United States recorded a flurry of seismic activity in the ten days following the
          Landers earthquake. Seismologists recorded 192 earthquakes outside of the aftershock zone during this time—four times the amount in the ten days proceeding
          the Landers quake. Even more surprising was that these earthquakes occurred at great distances from the aftershock zone, with many recorded hundreds or even thousands of miles
          from the mainshock epicenter.</p>
      </section>
      <section id='section5' class='step' step-num='6'>

        <p>Placing each earthquake as a dot on a timeline before and after the mainshock reveals the striking pattern.
          There is an especially large burst of activity in the three days following the mainshock, after which things taper off.
          This event was one of the first reports of <a class="btn" href="#triggered-modal">remotely triggered earthquakes</a> to gain wide recognition. Most scholars were convinced
          that this increase in seismic activity was triggered by energy sent out from the Landers quake, but many questioned how relevant it was.</p>
      </section>
      <section id='section6' class='step' step-num='7'>

        <p>Most earthquakes are small (M2.5–M4.0). These quakes are not typically felt by people, and are only recorded by sensitive <a class="btn" href="#seismograph-modal">seismographs</a>.
          Earthquakes of magnitude 4.0–5.0 can cause shaking that might knock things off your shelf, but they’re unlikely to cause structural damage.
          What we’re really concerned about are quakes greater than M5.5; only one of the 192 earthquakes following the Landers mainshock met this criterion.</p>
      </section>
      <section id='section7' class='step' step-num='8'>

        <p>Over the next 15 years there were numerous papers published on remote triggering of earthquakes. It became well accepted
          that large earthquakes often trigger small earthquakes at long distances, and are usually followed by increases in seismicity. However, the question of
          whether <a class="btn" href="#source-modal">source events</a> could remotely trigger large earthquakes (M5.5+) remained contentious. Several researchers argued that the largest earthquakes (M8.0+) could
          remotely trigger M5.5+ quakes, but not all were convinced. Scientists squabbled over statistical details and seismic mechanisms until 2012, when we got a unique glimpse
          into the possibilities of remote triggering.</p>
      </section>
      <section id='section8' class='step' step-num='9'>

        <p>The spring of 2012 was an unusually quiet time for large earthquakes. In the ten days
          from April 1st to April 11th there were only five M5.5+ earthquakes. Note that from here on we will only consider earthquakes larger than M5.5.</p>
      </section>
      <section id='section9' class='step' step-num='10'>

        <p>On the afternoon of April 11th 2012, a massive M8.6 earthquake struck off the coast of Sumatra. The temblor triggered many aftershocks (not shown here)
          . This quake was unique for its size and mechanism. To date, this is the largest ever recorded
          <a class="btn" href="#strike-modal">strike-slip earthquake</a>.</p>
      </section>
      <section id='section10' class='step' step-num='11'>

        <p>In the ten days following the Sumatra mainshock, 44 earthquakes M5.5+ were recorded. The statistics were clear: this nine-fold increase was highly
          significant, and most researchers agreed the likely explanation was remote triggering by the M8.6 Sumatra earthquake. This massive triggering of large
          earthquakes was unprecedented, and many wondered if the strike-slip mechanism at such a large magnitude was a unique combination that led to this outsized response.</p>
      </section>
      <section id='section11' class='step' step-num='12'>

        <p>When earthquakes strike, they send out <a class="btn" href="#waves-modal">seismic waves</a> that travel through the earth’s crust. These waves often propagate out from the mainshock in a '+' pattern
          meeting at the opposite side of the earth (the <a class="btn" href="#antipode-modal">antipode</a>). Analysis of the Sumatra quake showed that nearly all of the triggered earthquakes
          fell within the seismic waves from the mainshock.</p>
      </section>
      <section id='section12' class='step' step-num='13'>

        <p>The 2012 Sumatra quake showed that it was possible for a large earthquake to trigger other large earthquakes on the other side of the world, but the question remained: how common was
          this phenomenon? Many argued that the Sumatra quake was an outlier, and rigorous statistical analysis was needed to prove otherwise. Recently, a small group of researchers at
          Oregon State University carried out an analysis of 47 years of earthquake data to look for statistical evidence of remote earthquake triggering. Their method took each large mainshock (M7.0+)
          and then divided the globe into slices of ten <a class="btn" href="#degrees-modal">degrees</a> each emanating outward from the mainshock (the 30 degrees surrounding the mainshock was disregarded as it was already known to have elevated
          earthquake levels).
          For each slice, they compared the rate of M5.0+ earthquakes in the three days following the
          mainshock to a historical average to determine a <a class="btn" href="#rate-modal">relative rate</a> of earthquakes.</p>
      </section>
      <section id='section13' class='step' step-num='14'>

        <p>The researchers found that in the three days following the largest earthquakes (M8.0+), the rate of M5.5+ earthquakes at certain locations was elevated as much as twice the average.
          Two main regions—around 80 degrees and in the 30 degrees surrounding the antipode—have significantly elevated rates. The area around the antipode is particularly intriguing, as that is
          typically where seismic waves from the mainshock converge. Although suggestive, skeptics may argue that these results merely show a correlation—without causation—between large mainshocks and elevated rates of M5.5+
          quakes. However, there have been a handful of documented cases of remote triggering of large quakes with a demonstrated seismic mechanism that more convincingly show causation.</p>
      </section>
      <section id='section16' class='step' step-num='17'>

        <p>On September 11th 2008, a M6.6 earthquake struck off the coast of Halmahera, Indonesia. The quake sent seismic waves out towards Japan...</p>
      </section>
      <section id='section17' class='step' step-num='18'>

        <p>Twenty-one minutes after the Papua New Guinea mainshock, a M6.9 eathquake was recorded off the Eastern coast of Hokkaido, Japan. The Hokkaido quake
          hit mere seconds after the seismic waves from the Papua New Guinea mainshock landed. Detailed analysis showed that the Hokkaido quake
          was directly triggered by the seismic waves from the Papua New Guinea quake. Though this is perhaps the most compelling example, there have been a handful of other studies
          demonstrating similar results of direct remote triggering via a seismic mechanism.</p>
      </section>

    </div>
    <div id="footer">
      <div id="outro">
        <p>So, what does all of this mean for helping to predict earthquake risk? We’ve now seen that large earthquakes trigger hundreds to thousands of smaller earthquakes at great distances beyond the traditional aftershock zone. This finding is
          well accepted,
          though the significance of these small triggered quakes is unclear. It’s possible that these quakes can alter earthquake risk by either relieving or transferring stress in faults where they strike, but
          this is poorly understood and more research is needed. The more relevant finding is that the largest earthquakes can trigger other large earthquakes at remote distances. Importantly, we’ve seen that
          the triggered quakes are most likely to strike in the path of the mainshock seismic waves. Since the seismic waves converge at the antipode, this means that regions directly opposite a large mainshock should be
          on high alert for at least three days, after which the relative risk reduces. Particularly concerning, is that some studies have noted that remotely triggered quakes can occur in areas that are not considered fault zones, meaning
          they are less prepared and thus at higher risk of damage to property and to people.</p>
        <p>However, many scientist still question how common remote triggering of large earthquakes is, and the literature in this area
          remains in disagreement. It is crucial that we devote more research on the seismic mechanisms involved, so that we may better
          predict where and when risk of remotely triggered quakes is greatest. For example, why were so many large earthquakes triggered by the 2012 Sumatra earthquake? Was the strike-slip fracture mechanism a factor in that
          case? Some have also noted periods of quiesence before and/or after large mainshocks, arguing that the stress buildup and release—like an elastic band—may be important in predicting remote triggering—a question that deserves further
          attention. Ultimately more research is needed to determine
          the details, exact risk, and likelihood of these events, but given the evidence so far, next time I see a big earthquake in the news, I’ll be on the lookout to see if it’s on the other side of the world as me—something that once may have
          been reassuring, now concerning.
        </p>
      </div>
      <div id="methods">
        <div id="methods-title">Methods</div>
        <p>For the Landers and Sumatra earthquakes, data was retrieved from the USGS Earthquake Catalog for ten days before and after the mainshock. The Landers
          data included all earthquakes greater than M2.5, and was limited to the Western United States. The Sumatra data was limited to M5.5+ earthquakes, and was
          collected worldwide. For the Landers and Sumatra data, aftershocks and foreshocks were considered as any quake occurring within 2 rupture lengths of the mainshock,
          and were excluded from all designations of earthquakes ten days before or after the mainshock. Analysis of the relative rate of M5.5+ earthquakes following large earthquakes
          was based on O’Malley, R. T., Mondal, D., Goldfinger, C., & Behrenfeld, M. J. (2018). Evidence of systematic triggering at teleseismic distances following large earthquakes. <i>Scientific reports</i>. and was kindly provided by Mr. Robert
          O'Malley.
          Data on the remote triggering of the Hokkaido earthquake was sourced from Lin, C. H. (2012). Remote Triggering of the M w 6.9 Hokkaido Earthquake as a Result of the M w 6.6 Indonesian Earthquake on September 11, 2008. <i>Terrestrial,
            Atmospheric & Oceanic Sciences</i>.</p>
      </div>
    </div>
  </div>
  <script type="text/javascript">
    let small_screen = document.documentElement.clientWidth < 1000 ? true : false
    //if (!small_screen) {
    //initialize map
    mapboxgl.accessToken = 'pk.eyJ1Ijoid2NoYXNlMTQiLCJhIjoiY2p2dnYwOXBvMGJvNDQzcDkxcTZqNWd3dCJ9.UqxE9xtZJevAQem-lKCYnA';
    let map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/wchase14/cjx91ap6p29d01cpweae7p2bs',
      fitBounds: [
        [-163.125, 70.02058730174062],
        [172.265625, -55.17886766328199]
      ],
      zoom: 1.1,
      interactive: false
    });
    //for polygons
    //area for mapbox fly-tos
    let chapters = {
      'welcome': [
        [-163.125, 70.02058730174062],
        [183.1640625, -54.77534585936447]
      ],
      'section1': [
        [-145.546875, 53.12040528310657],
        [-101.6015625, 21.453068633086783]
      ],
      'section2': {
        bearing: 0,
        center: [131.380, 32.789],
        zoom: 7.87,
        speed: 0.7,
        pitch: 60.00
      },
      'section3': [
        [79.62890625, -17.476432197195518],
        [168.134765625, 53.067626642387374]
      ]
    };

    //////////////////////////
    // Mapbox+D3 Connection
    //////////////////////////
    // Get Mapbox map canvas container
    // Setup svg dims and margins
    let canvas = map.getCanvasContainer();
    let svg = d3.select(canvas).append("svg").attr("id", "my_svg");
    let svgSelect = document.getElementById("my_svg");
    let rect = svgSelect.getBoundingClientRect();
    const max_width = 800;
    const width = rect.width;
    const height = rect.height;
    const margin = ({
      top: 50,
      right: (width > max_width) ? (width - max_width) / 2 : 20,
      bottom: width < 500 ? 20 : 70,
      left: (width > max_width) ? (width - max_width) / 2 : 20
    });

    // Set up svg groups so that last one will be on top
    let before = svg.append("g");
    let aftershock = svg.append("g");
    let trigger = svg.append("g");
    let mainshock = svg.append("g");
    let mainshockSumatra = svg.append("g");
    let line1 = svg.append("g");
    let line2 = svg.append("g");
    let line3 = svg.append("g");
    let line4 = svg.append("g");
    let line5 = svg.append("g");
    let mainshockHokkaido = svg.append("g");
    let triggeredHokkaido = svg.append("g");

    // Draw GeoJSON data with d3
    let circles;

    // Scales
    //landers domain [2.5, 7.3]
    aScale = d3.scaleSqrt()
      .range([5, 22]);

    colorScale = d3.scaleSequential(d3.interpolateHcl("#F79567", "#c3402c"));

    timeParse = d3.timeParse("%Y-%m-%d %H:%M:%S");
    timeScale = d3.scaleTime();

    timeScaleBefore = d3.scaleTime()
      .range([margin.left, width / 2 - 20]);
    timeScaleTriggered = d3.scaleTime()
      .range([width / 2 + 20, width - margin.right]);
    radScale = d3.scaleLinear()
      .domain([300, 800])
      .range([6, 10])
      .clamp(true);
    //clean data function
    function clean(data) {
      for (const d of data.features) {
        const date = timeParse(d.properties.time);
        d.properties.date = date;
        d.properties.day = d3.timeDay(date);
      }
      return data;
    };

    function csvClean(data) {
      for (const d of data) {
        d.rel_rate = +d.rel_rate;
      }
      return data;
    };
    //rand number function
    function randNum(min, max) {
      return Math.random() * (max - min) + min;
    }

    //define URLs for data sources
    const landers_before_url = "https://gist.githubusercontent.com/will-r-chase/375d6366e6c32caf3862d1f6154f87a0/raw/f632753fc5940ac57e55276f38bca2262cb87907/landers_before2.geojson";
    const landers_mainshock_url = "https://gist.githubusercontent.com/will-r-chase/97555d4d4870f6acb2d3ca6708a5c61d/raw/3b78c10904ccfd968d5c06b6c8a04f0edc724273/landers_mainshock.geojson";
    const landers_aftershocks_url = "https://gist.githubusercontent.com/will-r-chase/ab84dc036cbe1f444bc27a349bb1a8bb/raw/962b541ef08baaaf10479b88306ca467f7ced355/landers_aftershocks.geojson";
    const landers_triggered_url = "https://gist.githubusercontent.com/will-r-chase/b510d63e4cfabe7c52a053a50a9faeac/raw/a463bddcac56aa827e15a96d372e19854c99373d/landers_triggered2.geojson";
    const sumatra_before_url = "https://gist.githubusercontent.com/will-r-chase/5cb1d0f0d043d3a3420a0be9d0eb3b58/raw/2542da1200c6ce637c4f80f12ff328c7873b564b/sumatra_before.geojson";
    const sumatra_mainshock_url = "https://gist.githubusercontent.com/will-r-chase/5e3e1470002a9bb53465c610faea0959/raw/07c39e495864ecc02aa5b683379af33e3dc9a259/indianOcean_mainshock.geojson";
    const sumatra_triggered_url = "https://gist.githubusercontent.com/will-r-chase/cb0f15205c78e792fda1ffb3a753946f/raw/1c909965e19b283c597a125dc49d70ff92f2f4ae/sumatra_triggered.geojson";
    const bars_url = "https://gist.githubusercontent.com/will-r-chase/8dea02691e0b03044711ea1f7ba97310/raw/6bfd551a460ba1118c19c3f9e9d84a8c07a26ee7/m8_day1-3_relrates.csv";
    const oita_mainshock_url = "https://gist.githubusercontent.com/will-r-chase/29e7d6564c96049fb5962e6c015150b4/raw/f0a3cca5753d88c9d780c1ab6cf8147acf0889ab/oitaMainshock.geojson";
    const oita_triggered_url = "https://gist.githubusercontent.com/will-r-chase/bf22e59067f4ebb827cda5d81534dbd1/raw/29e28b6d04b7933664ed3357e5548255bc737e06/oitaTriggered.geojson";
    const hokkaido_mainshock_url = "https://gist.githubusercontent.com/will-r-chase/035234ed3d84b08bbaca18a68afaa0f3/raw/00352a1b23b761b84876932eff2ec25c1ecf372c/hokkaidoMainshock.geojson";
    const hokkaido_triggered_url = "https://gist.githubusercontent.com/will-r-chase/4d6d64f50fe9db1094789afd34284470/raw/2cfd89ca9bea89b9e2810591ed79498107f34585/hokkaidoTriggered.geojson";


    //function to draw strain waves
    map.on('load', function() {
      map.fitBounds(chapters['welcome']);
      map.addSource('strainWavesDat', {
        type: 'geojson',
        data: 'https://gist.githubusercontent.com/will-r-chase/72b206dd2ba17889ba98075d693db1bd/raw/cc17e7c23ef33d0c69a43ba9addccab6b2dc1270/strain_waves.geojson'
      });
      map.addLayer({
        "id": "strainWaves",
        "type": "fill",
        "source": "strainWavesDat",
        'layout': {},
        'paint': {
          'fill-color': '#A03F85',
          'fill-opacity': 0
        }
      });
    });

    // For each enter step, read and draw data
    function initData(source, myGroup, myClass, myDomain, myTimeRange, myExtraDelay, myEase = d3.easeCubicInOut, myDuration = 650) {
      d3.json(source, function(err, data) {
        let cleanDat = clean(data)
        drawData(cleanDat, myGroup, myClass, myDomain, myTimeRange, myExtraDelay, myEase, myDuration);
      })
    };
    // For each enter step, read and draw data
    function initPoints(source, myGroup, myClass, myDomain, myTimeRange, myExtraDelay, myEase = d3.easeCubicInOut, myDuration = 650) {
      d3.json(source, function(err, data) {
        drawPoints(data, myGroup, myClass, myDomain, myTimeRange, myExtraDelay, myEase, myDuration);
      })
    };

    function initChart(source1, source2) {
      d3.json(source1, function(err, dataBefore) {
        d3.json(source2, function(err, dataTriggered) {
          if (err) console.log(err);
          let cleanBefore = clean(dataBefore);
          let cleanTriggered = clean(dataTriggered);
          drawChart(cleanBefore, cleanTriggered);
        });
      });
    };

    function initChartBackwards(source1, source2) {
      d3.json(source1, function(err, dataBefore) {
        d3.json(source2, function(err, dataTriggered) {
          if (err) console.log(err);
          let cleanBefore = clean(dataBefore);
          let cleanTriggered = clean(dataTriggered);
          drawChartBackwards(cleanBefore, cleanTriggered);
        });
      });
    };

    function initChartHighlight(source1, source2) {
      d3.json(source1, function(err, dataBefore) {
        d3.json(source2, function(err, dataTriggered) {
          if (err) console.log(err);
          let cleanBefore = clean(dataBefore);
          let cleanTriggered = clean(dataTriggered);
          highlightChart(cleanBefore, cleanTriggered);
        });
      });
    };

    function exitChartHighlight(source1, source2) {
      d3.json(source1, function(err, dataBefore) {
        d3.json(source2, function(err, dataTriggered) {
          if (err) console.log(err);
          let cleanBefore = clean(dataBefore);
          let cleanTriggered = clean(dataTriggered);
          reverseHighlightChart(cleanBefore, cleanTriggered);
        });
      });
    };

    function exitChart(source1, source2) {
      d3.json(source1, function(err, dataBefore) {
        d3.json(source2, function(err, dataTriggered) {
          if (err) console.log(err);
          let cleanBefore = clean(dataBefore);
          let cleanTriggered = clean(dataTriggered);
          reverseChart(cleanBefore, cleanTriggered);
        });
      });
    };

    function initBars(source) {
      d3.csv(source, function(err, data) {
        if (err) console.log(err);
        let dataClean = csvClean(data);
        console.log(dataClean)
        drawBars(dataClean);
      });
    };

    function initBarsHighlight(source) {
      d3.csv(source, function(err, data) {
        if (err) console.log(err);
        let dataClean = csvClean(data);
        console.log(dataClean)
        highlightBars(dataClean);
      });
    };

    function initRedrawCircles(source) {
      d3.csv(source, function(err, data) {
        if (err) console.log(err);
        let dataClean = csvClean(data);
        console.log(dataClean)
        redrawCircles(dataClean);
      });
    };
    //////////////
    // D3 stuff //
    //////////////
    // Project GeoJSON coordinate to the map's current state
    function project(d) {
      return map.project(new mapboxgl.LngLat(+d[0], +d[1]));
    }

    //Main draw function
    function drawData(data, group, pointClass, domain, timeRange, extraDelay = 0, Ease, Duration) {
      // set scale domain
      aScale.domain(domain);
      colorScale.domain(domain);
      timeScale
        .domain(d3.extent(data.features.map(d => d.properties).map(d => d.date)))
        .range(timeRange);
      // Add circles
      circles = group.selectAll(pointClass)
        .data(data.features)
        .enter()
        .append("circle")
        .attr("class", pointClass)
        .attr("r", 0)
        .attr("fill", d => colorScale(d.properties.mag))
        .attr("day", d => d.properties.day)
        .style("opacity", 0.7);

      circles
        .transition()
        .delay(d => extraDelay + timeScale(d.properties.date))
        .duration(Duration)
        .ease(Ease)
        .attr("r", d => aScale(d.properties.mag));
      // Call the update function
      update();
      // Update on map interaction
      map.on("viewreset", update);
      map.on("move", update);
      map.on("moveend", update);
    }

    function drawPoints(data, group, pointClass, domain, timeRange, extraDelay = 0, Ease, Duration) {
      // set scale domain
      aScale.domain(domain);
      colorScale.domain(domain);

      // Add circles
      circles = group.selectAll(pointClass)
        .data(data.features)
        .enter()
        .append("circle")
        .attr("class", pointClass)
        .attr("r", 0)
        .attr("fill", d => colorScale(d.properties.mag))
        .style("opacity", 0.7);

      circles
        .transition()
        .delay(extraDelay)
        .duration(Duration)
        .ease(Ease)
        .attr("r", d => aScale(d.properties.mag));
      // Call the update function
      update();
      // Update on map interaction
      map.on("viewreset", update);
      map.on("move", update);
      map.on("moveend", update);
    };
    // Update d3 shapes' positions to the map's current state
    function update() {
      console.log("update");
      svg.selectAll("circle").attr("cx", function(d) {
          return project(d.geometry.coordinates).x
        })
        .attr("cy", function(d) {
          return project(d.geometry.coordinates).y
        });
    }

    //function to draw stacked dot histogram
    function drawChart(dataBefore, dataTriggered) {
      console.log("dataBefore", dataBefore);
      console.log("dataTriggered", dataTriggered);
      timeScaleBefore.domain(d3.extent(dataBefore.features.map(d => d.properties).map(d => d.day)));
      timeScaleTriggered.domain(d3.extent(dataTriggered.features.map(d => d.properties).map(d => d.day)));
      const arrowPath = `M ${width/2 - 130},${height/3.6} C ${width/2 - 130},${height/4 + 60} ${width/2 - 130},${height/4 + 70} ${width/2 - 10},${height/4 + 70}`
      const rad =

        // Define simple arrowhead marker
        svg.append('defs')
        .append("marker")
        .attr("id", "arrowhead")
        .attr("viewBox", "-10 -10 20 20")
        .attr("refX", 0)
        .attr("refY", 0)
        .attr("markerWidth", 20)
        .attr("markerHeight", 20)
        .attr("stroke-width", 1)
        .attr("orient", "auto")
        .append("polyline")
        .attr("stroke-linejoin", "bevel")
        .attr("points", "-6.75,-6.75 0,0 -6.75,6.75");

      //mainshock line
      line = svg.append("g")
        .append("line")
        .attr("x1", width / 2)
        .attr("x2", width / 2)
        .attr("y1", height / 5)
        .attr("y2", height - margin.bottom)
        .attr("class", "mainshock-line")
        .style("opacity", 0)
        .style("stroke", "#C3402C") //#E3191C
        .style("stroke-width", 3)
        .style("stroke-dasharray", 5);

      //x axis before
      axisBefore = svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .attr("class", "chart-axis")
        .style("opacity", 0)
        .call(d3.axisBottom(timeScaleBefore)
          .ticks(5)
          .tickFormat(d3.timeFormat("%b %d"))
          .tickSizeOuter(0));
      //x axis after
      axisTriggered = svg.append("g")
        .attr("transform", `translate(0, ${height - margin.bottom})`)
        .attr("class", "chart-axis")
        .style("opacity", 0)
        .call(d3.axisBottom(timeScaleTriggered)
          .ticks(5)
          .tickFormat(d3.timeFormat("%b %d"))
          .tickSizeOuter(0));

      axisBefore
        .transition()
        .delay(100)
        .duration(2000)
        .style("opacity", 1);

      beforeLabel = d3.select(canvas)
        .append("div")
        .attr("class", "chart-label")
        .html(
          "Earthquakes 10 days before the Landers mainshock"
        )
        .style("position", "absolute")
        .style("width", width < 500 ? "150px" : "200px")
        .style("opacity", 0)
        .style("left", width / 2 - (width < 500 ? 175 : 250) + "px")
        .style("top", height / (width < 500 ? 1.9 : 1.55) + "px")
        .style("text-anchor", "left")
        .transition()
        .delay(0) //2500
        .duration(2000)
        .style("opacity", 1);

      before
        .selectAll(".landers-before")
        .data(dataBefore.features)
        .transition()
        .delay(d => 0 + randNum(0, 100) + d.properties.id_overall * 100) //7000
        .attr("r", radScale(width))
        .style("opacity", 1)
        .attr("fill", "#872B32")
        .attr("cx", d => timeScaleBefore(d.properties.day))
        .attr("cy", d => height - margin.bottom - (d.properties.id_day * (radScale(width) * 2)));

      mainshockLabel = d3.select(canvas)
        .append("div")
        .attr("class", "chart-label")
        .html(
          "On Jan 28th 1992, a magnitude 7.3 earthquake strikes near Landers, California"
        )
        .style("position", "absolute")
        .style("width", (width < 500) ? "150px" : "200px")
        .style("opacity", 0)
        .style("left", width / 2 - (width < 500 ? 170 : 220) + "px")
        .style("top", height / 3.6 - (width < 500 ? 80 : 60) + "px")
        .style("text-anchor", "left")
        //.style("font-size", "14px")
        .transition()
        .delay(0) //11000
        .duration(2000)
        .style("opacity", 1);

      arrow = svg.append("path")
        .attr('marker-end', 'url(#arrowhead)')
        .attr("d", arrowPath)
        .attr("class", "myArrow")
        .style('opacity', 0)
        .style("fill", "none")
        .attr("stroke-width", 1)
        .attr("stroke", "black")
        .transition()
        .delay(0) //12000
        .duration(1500)
        .style('opacity', 1);

      line
        .transition()
        .delay(0) //13000
        .duration(1000)
        .style("opacity", 1)

      axisTriggered
        .transition()
        .delay(0) //15000
        .duration(2000)
        .style("opacity", 1);

      triggeredLabel = d3.select(canvas)
        .append("div")
        .attr("class", "chart-label")
        .html(
          "Earthquakes 10 days after the Landers mainshock"
        )
        .style("position", "absolute")
        .style("width", (width < 500) ? "150px" : "200px")
        .style("opacity", 0)
        .style("left", width / 2 + (width < 500 ? 45 : 200) + "px")
        .style("top", height / 2 + (height < 1000 ? -170 : 0) + "px")
        .style("text-anchor", "left")
        .transition()
        .delay(0) //17500
        .duration(2000)
        .style("opacity", 1);

      trigger
        .selectAll(".landers-triggered")
        .data(dataTriggered.features)
        .transition()
        .delay(d => 0 + randNum(20, 150) + d.properties.id_overall * 30) //20000
        .attr("r", radScale(width))
        .style("opacity", 1)
        .attr("fill", "#872B32")
        .attr("cx", d => timeScaleTriggered(d.properties.day))
        .attr("cy", d => height - margin.bottom - (d.properties.id_day * (radScale(width) * 2)));

    };

    function drawChartBackwards(dataBefore, dataTriggered) {
      timeScaleBefore.domain(d3.extent(dataBefore.features.map(d => d.properties).map(d => d.day)));
      timeScaleTriggered.domain(d3.extent(dataTriggered.features.map(d => d.properties).map(d => d.day)));

      before
        .selectAll(".landers-before")
        .data(dataBefore.features)
        .attr("r", radScale(width))
        .attr("fill", d => d.properties.mag > 5 ? "#872B32" : "#373536") //#DC0505
        .style("opacity", d => d.properties.mag > 5 ? 1 : 0.5)
        .attr("cx", d => timeScaleBefore(d.properties.day))
        .attr("cy", d => height - margin.bottom - (d.properties.id_day * (radScale(width) * 2)));


      trigger
        .selectAll(".landers-triggered")
        .data(dataTriggered.features)
        .attr("r", radScale(width))
        .attr("fill", d => d.properties.mag > 5 ? "#872B32" : "#373536") //#C3402C
        .style("opacity", d => d.properties.mag > 5 ? 1 : 0.5)
        .attr("cx", d => timeScaleTriggered(d.properties.day))
        .attr("cy", d => height - margin.bottom - (d.properties.id_day * (radScale(width) * 2)));

    };

    function highlightChart(dataBefore, dataTriggered) {
      before
        .selectAll(".landers-before")
        .data(dataBefore.features)
        .transition()
        .delay(300)
        .duration(1000)
        .attr("fill", d => d.properties.mag > 5 ? "#872B32" : "#373536") //#C3402C
        .style("opacity", d => d.properties.mag > 5 ? 1 : 0.5);

      trigger
        .selectAll(".landers-triggered")
        .data(dataTriggered.features)
        .transition()
        .delay(300)
        .duration(1000)
        .attr("fill", d => d.properties.mag > 5 ? "#872B32" : "#373536") //#C3402C
        .style("opacity", d => d.properties.mag > 5 ? 1 : 0.5);
    };

    function reverseHighlightChart(dataBefore, dataTriggered) {
      before
        .selectAll(".landers-before")
        .data(dataBefore.features)
        .transition()
        .delay(700)
        .duration(1000)
        .attr("fill", "#872B32")
        .style("opacity", 1);

      trigger
        .selectAll(".landers-triggered")
        .data(dataTriggered.features)
        .transition()
        .delay(700)
        .duration(1000)
        .attr("fill", "#872B32")
        .style("opacity", 1);
    };
    //function to draw stacked dot histogram
    function reverseChart(dataBefore, dataTriggered) {
      aScale.domain([2.5, 7.3]);
      colorScale.domain([2.5, 7.3]);
      timeScaleBefore.domain(d3.extent(dataBefore.features.map(d => d.properties).map(d => d.day)));
      timeScaleTriggered.domain(d3.extent(dataTriggered.features.map(d => d.properties).map(d => d.day)));

      before
        .selectAll(".landers-before")
        .data(dataBefore.features)
        .transition()
        .attr("r", d => aScale(d.properties.mag))
        .style("opacity", 0.3)
        .attr("fill", "#515151");
      update();

      trigger
        .selectAll(".landers-triggered")
        .data(dataTriggered.features)
        .transition()
        .attr("r", d => aScale(d.properties.mag))
        .style("opacity", 0.7)
        .attr("fill", d => colorScale(d.properties.mag));

      update();
    };

    function drawBars(data) {
      innerRadius = width < 500 ? 50 : 190,
        outerRadius = Math.min(width, height) / 2.1;

      bars = svg.append("g")
        .attr("class", "bar-chart")
        .attr("transform", `translate(${width/2}, ${height/2})`);

      // X scale
      var x = d3.scaleBand()
        .range([0, 2 * Math.PI])
        .align(0)
        .domain(data.map(function(d) {
          return d.deg;
        }));

      // Y scale
      var y = d3.scaleRadial()
        .range([innerRadius, outerRadius])
        .domain([0, d3.max(data, d => d.rel_rate)]);

      bars
        .selectAll("path")
        .data(data)
        .enter()
        .append("path")
        .style("opacity", 0)
        .attr("d", d3.arc()
          .innerRadius(innerRadius)
          .outerRadius(function(d) {
            return y(d.rel_rate);
          })
          .startAngle(function(d) {
            return x(d.deg);
          })
          .endAngle(function(d) {
            return x(d.deg) + x.bandwidth();
          })
          .padAngle(0.01)
          .padRadius(innerRadius))
        .transition()
        .delay(3500)
        .duration(1000)
        .style("opacity", 1);

      xAxis = g => g
        .attr("text-anchor", "middle")
        .call(g => g.selectAll("g")
          .data(data)
          .enter().append("g")
          .attr("transform", d => `
                  rotate(${((x(d.deg) + x.bandwidth() / 2) * 180 / Math.PI - 90)})
                  translate(${innerRadius},0)
                `)
          .call(g => g.append("line")
            .attr("x2", -5)
            .attr("stroke", "#000"))
          .call(g => g.append("text")
            .attr("transform", d => (x(d.deg) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ?
              "rotate(90)translate(0,16)" :
              "rotate(-90)translate(0,-9)")
            .text(d => d.deg)))

      yAxis = g => g
        .attr("text-anchor", "middle")
        .call(g => g.append("text")
          .attr("y", d => -y(y.ticks(5).pop()))
          .attr("dy", "-0.7em")
          .text("Relative rate"))
        .attr("font-size", "16px")
        .call(g => g.selectAll("g")
          .data(y.ticks(5).slice(1))
          .enter().append("g")
          .call(g => g.append("circle")
            .attr("class", "bar-axis")
            .attr("r", y))
          .call(g => g.append("text")
            .attr("y", d => -y(d))
            .attr("dy", "0.45em")
            .attr("stroke", "#fff")
            .attr("stroke-width", 3)
            .text(y.tickFormat(5, "s"))
            .clone(true)
            .attr("fill", "#000")
            .attr("font-size", "16px")
            .attr("stroke", "none")))

      // svg.append("g")
      //   .attr("class", "bar-axis")
      //   .attr("transform", `translate(${width/2}, ${height/2})`)
      //   .call(xAxis);
      svg.append("g")
        .attr("class", "bar-axis")
        .attr("transform", `translate(${width/2}, ${height/2})`)
        .style("opacity", 0)
        .call(yAxis)
        .transition()
        .delay(3500)
        .duration(1000)
        .style("opacity", 0.9);

      var myimage = svg.append('image')
        .attr('xlink:href', 'earth_outline.png')
        .attr("class", "globe")
        .attr('width', innerRadius * 1.9)
        .attr('height', innerRadius * 1.9)
        .attr("x", width / 2 - innerRadius / 1.05)
        .attr("y", height / 2 - innerRadius / 1.05);

      var arc = d3.arc()
        .innerRadius(innerRadius / 1.1)
        .outerRadius(innerRadius / 1.04)
        .startAngle(Math.PI);

      var righthand = svg.append("g")
        .attr("transform", `translate(${width/2}, ${height/2})`)
        .append("path")
        .datum({
          endAngle: 0
        })
        .attr("class", "strain-wave")
        .style("opacity", 0)
        .attr("fill", "#A03F85")
        .attr("d", arc);

      var lefthand = svg.append("g")
        .attr("transform", `translate(${width/2}, ${height/2})`)
        .append("path")
        .datum({
          endAngle: 2 * Math.PI
        })
        .attr("class", "strain-wave")
        .style("opacity", 0)
        .attr("fill", "#A03F85") //#961D72
        .attr("d", arc);

      svg.append("g")
        .append("circle")
        .attr("class", "mainshockDummy")
        .attr("cx", width / 2)
        .attr("cy", height / 2 + innerRadius / 1.08)
        .attr("r", 0)
        .attr("fill", "#C3402C")
        .style("opacity", 1)
        .transition()
        .delay(1000)
        .duration(700)
        .ease(d3.easeElastic)
        .attr("r", width < 500 ? 7 : 15);

      var deadzone = svg.append("g")
        .attr("transform", `translate(${width/2}, ${height/2})`)
        .append("path")
        .attr("class", "deadzone")
        .style("opacity", 0)
        .attr("fill", "#9A9A9A")
        .attr("d", d3.arc()
          .innerRadius(innerRadius)
          .outerRadius(innerRadius / 0.8)
          .startAngle(Math.PI / 1.15)
          .endAngle(Math.PI * 1.13)
        )
        .transition()
        .delay(3500)
        .duration(1000)
        .style("opacity", 0.5);

      righthand.transition()
        .delay(1500)
        .duration(1000)
        .style("opacity", 1)
        .attrTween("d", function(d) {
          var start = {
            startAngle: Math.PI,
            endAngle: Math.PI
          };
          var interpolate = d3.interpolate(start, d);
          return function(t) {
            return arc(interpolate(t));
          };
        });

      lefthand.transition()
        .delay(1500)
        .duration(1000)
        .style("opacity", 1)
        .attrTween("d", function(d) {
          var start = {
            startAngle: Math.PI,
            endAngle: Math.PI
          };
          var interpolate = d3.interpolate(start, d);
          return function(t) {
            return arc(interpolate(t));
          };
        });

      const arrowPath1 = `M ${width/2 - (width < 500 ? 40 : 100)},${height/1.25} C ${width/2},${height/1.25} ${width/2},${height/1.4} ${width/2},${height / 2 + innerRadius / 0.95}`

      mainshockBarLabel = d3.select(canvas)
        .append("div")
        .attr("class", "bar-label")
        .html(
          "A large mainshock occurs, sending out seismic waves that meet at the antipode"
        )
        .style("position", "absolute")
        .style("width", width < 500 ? "150px" : "200px")
        .style("opacity", 0)
        .style("left", width / 2 - (width < 500 ? 180 : 280) + "px")
        .style("top", height / 1.3 - (width < 500 ? 10 : 0) + "px")
        .style("text-anchor", "left")
        .style("font-size", width < 500 ? "12px" : "16px")
        .style("line-height", "0.85rem")
        .transition()
        .delay(1200) //11000
        .duration(1000)
        .style("opacity", 1);

      arrow1 = svg.append("path")
        .attr('marker-end', 'url(#arrowhead)')
        .attr("d", arrowPath1)
        .attr("class", "bar-arrow")
        .style('opacity', 0)
        .style("fill", "none")
        .attr("stroke-width", 1)
        .attr("stroke", "black")
        .transition()
        .delay(1000) //12000
        .duration(1000)
        .style('opacity', 1);

      const arrowPath2 =
        `M ${width/2 + (width < 500 ? 50 : 90)},${height/1.25} C ${width/2 + (width < 500 ? 15 : 50)},${height/1.25} ${width/2 + (width < 500 ? 15 : 50)},${height/1.3} ${width/2 + (width < 500 ? 15 : 50)},${height/2 + innerRadius / 0.76}`

      deadzoneBarLabel = d3.select(canvas)
        .append("div")
        .attr("class", "bar-label")
        .html(
          "The region within 30 degrees of the mainshock is ignored"
        )
        .style("position", "absolute")
        .style("width", width < 500 ? "130px" : "200px")
        .style("opacity", 0)
        .style("left", width / 2 + (width < 500 ? 50 : 100) + "px")
        .style("top", height / 1.26 - (width < 500 ? 10 : 0) + "px")
        .style("text-anchor", "left")
        .style("font-size", width < 500 ? "12px" : "16px")
        .style("line-height", "0.85rem")
        .transition()
        .delay(3500) //11000
        .duration(1000)
        .style("opacity", 1);

      arrow2 = svg.append("path")
        .attr('marker-end', 'url(#arrowhead)')
        .attr("d", arrowPath2)
        .attr("class", "bar-arrow")
        .style('opacity', 0)
        .style("fill", "none")
        .attr("stroke-width", 1)
        .attr("stroke", "black")
        .transition()
        .delay(3500) //12000
        .duration(1000)
        .style('opacity', 1);

      //const arrowPath3 = `M ${width/2 + 250},${height/8} C ${width/2 + 250},${height/9} ${width/2 + 200},${height/9} ${width/2 + 150},${height/8}`

      rateBarLabel = d3.select(canvas)
        .append("div")
        .attr("class", "bar-label")
        .html(
          "Bars represent the relative rate of earthquakes in the three days following the mainshock compared to a historical average for each five-degree distance from the mainshock"
        )
        .style("position", "absolute")
        .style("width", width < 500 ? "90px" : "200px")
        .style("opacity", 0)
        .style("left", width / 2 + (width < 500 ? 90 : 280) + "px")
        .style("top", height / 20 - 5 + "px")
        .style("text-anchor", "left")
        .style("font-size", width < 500 ? "12px" : "16px")
        .style("line-height", "0.75rem")
        .style("text-align", width < 500 ? "right" : "left")
        .transition()
        .delay(3500) //11000
        .duration(1000)
        .style("opacity", 1);

      // arrow3 = svg.append("path")
      //   .attr('marker-end', 'url(#arrowhead)')
      //   .attr("d", arrowPath3)
      //   .attr("class", "bar-arrow")
      //   .style('opacity', 0)
      //   .style("fill", "none")
      //   .attr("stroke-width", 1)
      //   .attr("stroke", "black")
      //   .transition()
      //   .delay(7000) //12000
      //   .duration(1000)
      //   .style('opacity', 1);


    };

    function highlightBars(data) {
      d3.selectAll("g.bar-chart")
        .selectAll("path")
        .data(data)
        .transition()
        .delay(300)
        .duration(1000)
        .style("opacity", d => d.rel_rate > 1.5 ? 1 : 0.5)
        .style("fill", d => d.rel_rate > 1.5 ? "#872B32" : "#373536"); //#aa0303
    };

    function reverseHighlightBars() {
      d3.selectAll("g.bar-chart")
        .selectAll("path")
        .transition()
        .delay(300)
        .duration(500)
        .style("opacity", 1)
        .style("fill", "#872B32"); //#aa0303
    };

    function redrawCircles(data) {
      innerRadius = 190,
        outerRadius = Math.min(width, height) / 2.1;

      // Y scale
      var y = d3.scaleRadial()
        .range([innerRadius, outerRadius])
        .domain([0, d3.max(data, d => d.rel_rate)]);

      svg.append("g")
        .append("circle")
        .attr("class", "mainshockDummy")
        .attr("cx", width / 2)
        .attr("cy", height / 2 + innerRadius / 1.08)
        .attr("r", 15)
        .attr("fill", "#C3402C") // #E3191C
        .style("opacity", 1);

      yAxis = g => g
        .attr("text-anchor", "middle")
        .call(g => g.append("text")
          .attr("y", d => -y(y.ticks(5).pop()))
          .attr("dy", "-0.7em")
          .text("Relative rate"))
        .attr("font-size", "16px")
        .call(g => g.selectAll("g")
          .data(y.ticks(5).slice(1))
          .enter().append("g")
          .call(g => g.append("circle")
            .attr("class", "bar-axis")
            .attr("r", y))
          .call(g => g.append("text")
            .attr("y", d => -y(d))
            .attr("dy", "0.45em")
            .attr("stroke", "#fff")
            .attr("stroke-width", 3)
            .text(y.tickFormat(5, "s"))
            .clone(true)
            .attr("fill", "#000")
            .attr("font-size", "16px")
            .attr("stroke", "none")))

      svg.append("g")
        .attr("class", "bar-axis")
        .attr("transform", `translate(${width/2}, ${height/2})`)
        .style("opacity", 0.9)
        .call(yAxis);

    };

    function makeSquiggle(squigglePathId, followPathId, squiggleStep, squiggleAmplitude) {
      var followPath = document.getElementById(followPathId);
      var pathLen = followPath.getTotalLength();

      // Adjust step so that there are a whole number of steps along the path
      var numSteps = Math.round(pathLen / squiggleStep);

      var pos = followPath.getPointAtLength(0);
      var newPath = "M" + [pos.x, pos.y].join(',');
      var side = -1;
      for (var i = 1; i <= numSteps; i++) {
        var last = pos;
        var pos = followPath.getPointAtLength(i * pathLen / numSteps);

        // Find a point halfway between last and pos. Then find the point that is
        // perpendicular to that line segment, and is squiggleAmplitude away from
        // it on the side of the line designated by 'side' (-1 or +1).
        // This point will be the control point of the quadratic curve forming the
        // squiggle step.

        // The vector from the last point to this one
        var vector = {
          x: (pos.x - last.x),
          y: (pos.y - last.y)
        };
        // The length of this vector
        var vectorLen = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
        // The point halfwasy between last point and tis one
        var half = {
          x: (last.x + vector.x / 2),
          y: (last.y + vector.y / 2)
        };
        // The vector that is perpendicular to 'vector'
        var perpVector = {
          x: -(squiggleAmplitude * vector.y / vectorLen),
          y: (squiggleAmplitude * vector.x / vectorLen)
        };
        // No calculate the control point position
        var controlPoint = {
          x: (half.x + perpVector.x * side),
          y: (half.y + perpVector.y * side)
        };
        newPath += ("Q" + [controlPoint.x, controlPoint.y, pos.x, pos.y].join(','));
        // Switch the side (for next step)
        side = -side;
      }
      var squigglePath = document.getElementById(squigglePathId);
      squigglePath.setAttribute("d", newPath);
    }

    function strainArrows() {
      let hok_start = map.project([127.57324218750001, 1.4500404973608074])
      let hok_end = map.project([143.61328125, 42.16340342422401])
      let right_mdpt = map.project([144.228515625, 22.268764039073968])
      let left_mdpt = map.project([128.14453125, 26.194876675795218])
      let right_end = map.project([145.37109375, 41.64007838467894])
      let left_end = map.project([142.20703125, 42.35854391749705])
      let right_mdpt2 = map.project([140.625, 23.32208001137843])
      let left_mdpt2 = map.project([132.275390625, 25.562265014427492])
      let right_end2 = map.project([144.404296875, 42.032974332441405])
      let left_end2 = map.project([142.91015625, 42.48830197960227])

      const right_data = [hok_start, right_mdpt, right_end];
      const left_data = [hok_start, left_mdpt, left_end];
      const right_data2 = [hok_start, right_mdpt2, right_end2];
      const left_data2 = [hok_start, left_mdpt2, left_end2]

      line = d3.line()
        .x(d => d.x)
        .y(d => d.y)
        .curve(d3.curveCatmullRom.alpha(0.5));

      line1
        .append("path")
        .attr("id", "squiggle");
      line2
        .append("path")
        .attr("id", "squiggle2");
      line3
        .append("path")
        .attr("id", "squiggle3");
      line4
        .append("path")
        .attr("id", "squiggle4");
      line5
        .append("path")
        .attr("id", "squiggle5");

      center_line = svg.append("g")
        .append("line")
        .attr("id", "center-line")
        .attr("x1", hok_start.x)
        .attr("x2", hok_end.x)
        .attr("y1", hok_start.y)
        .attr("y2", hok_end.y)
        .style("fill", "none")
        .style("opacity", 0)
        .style("stroke", "#A03F85")
        .style("stroke-width", 5)

      right_line = svg.append("g")
        .append("path")
        .attr("d", line(right_data))
        .attr("id", "right-line")
        .style("fill", "none")
        .style("opacity", 0)
        .style("stroke", "#A03F85")
        .style("stroke-width", 5);

      left_line = svg.append("g")
        .append("path")
        .attr("id", "left-line")
        .attr("d", line(left_data))
        .style("fill", "none")
        .style("opacity", 0)
        .style("stroke", "#83c1c1")
        .style("stroke-width", 5);

      right_line2 = svg.append("g")
        .append("path")
        .attr("d", line(right_data2))
        .attr("id", "right-line2")
        .style("fill", "none")
        .style("opacity", 0)
        .style("stroke", "#A03F85")
        .style("stroke-width", 5);

      left_line2 = svg.append("g")
        .append("path")
        .attr("id", "left-line2")
        .attr("d", line(left_data2))
        .style("fill", "none")
        .style("opacity", 0)
        .style("stroke", "#A03F85")
        .style("stroke-width", 5);

      makeSquiggle("squiggle", "center-line", 40, 10);
      makeSquiggle("squiggle2", "right-line", 40, 10);
      makeSquiggle("squiggle3", "left-line", 40, 10);
      makeSquiggle("squiggle4", "right-line2", 40, 10);
      makeSquiggle("squiggle5", "left-line2", 40, 10);

      d3.select("#squiggle")
        .attr("class", "squiggle")
        .style("fill", "none")
        .style("opacity", 1)
        .style("stroke", "#A03F85")
        .style("stroke-width", 7)
        .attr("stroke-dasharray", function() {
          pathLength = this.getTotalLength();
          return pathLength;
        })
        .attr("stroke-dashoffset", pathLength)
        .transition()
        .ease(d3.easeLinear)
        .duration(2000)
        .attr("stroke-dashoffset", 0);

      d3.select("#squiggle2")
        .attr("class", "squiggle")
        .style("fill", "none")
        .style("opacity", 1)
        .style("stroke", "#A03F85")
        .style("stroke-width", 7)
        .attr("stroke-dasharray", function() {
          pathLength = this.getTotalLength();
          return pathLength;
        })
        .attr("stroke-dashoffset", pathLength)
        .transition()
        .ease(d3.easeLinear)
        .duration(2000)
        .attr("stroke-dashoffset", 0);

      d3.select("#squiggle3")
        .attr("class", "squiggle")
        .style("fill", "none")
        .style("opacity", 1)
        .style("stroke", "#A03F85")
        .style("stroke-width", 7)
        .attr("stroke-dasharray", function() {
          pathLength = this.getTotalLength();
          return pathLength;
        })
        .attr("stroke-dashoffset", pathLength)
        .transition()
        .ease(d3.easeLinear)
        .duration(2000)
        .attr("stroke-dashoffset", 0);

      d3.select("#squiggle4")
        .attr("class", "squiggle")
        .style("fill", "none")
        .style("opacity", 1)
        .style("stroke", "#A03F85")
        .style("stroke-width", 7)
        .attr("stroke-dasharray", function() {
          pathLength = this.getTotalLength();
          return pathLength;
        })
        .attr("stroke-dashoffset", pathLength)
        .transition()
        .ease(d3.easeLinear)
        .duration(2000)
        .attr("stroke-dashoffset", 0);

      d3.select("#squiggle5")
        .attr("class", "squiggle")
        .style("fill", "none")
        .style("opacity", 1)
        .style("stroke", "#A03F85")
        .style("stroke-width", 7)
        .attr("stroke-dasharray", function() {
          pathLength = this.getTotalLength();
          return pathLength;
        })
        .attr("stroke-dashoffset", pathLength)
        .transition()
        .ease(d3.easeLinear)
        .duration(2000)
        .attr("stroke-dashoffset", 0);
    };

    //function to remove selected points
    function eraseData(pointClass) {
      d3.selectAll(pointClass).remove()
    }
    //function to fade opacity of selected points
    function fadeData(pointClass) {
      svg.selectAll(pointClass)
        .transition()
        .duration(500)
        .style("opacity", 0.3)
        .attr("fill", "#515151");
    }

    ///if we have time make this a real function to restore colors to faded data
    function unfadeData(pointClass) {
      colorScale.domain([2.5, 7.3]);


      svg.selectAll(pointClass)
        .transition()
        .duration(500)
        .style("opacity", 0.3)
        .attr("fill", d => colorScale(d.properties.mag))
    }

    function hideEl(myClass) {
      d3.selectAll(myClass)
        .transition()
        .duration(500)
        .style("opacity", 0);
    }

    function showEl(myClass, opacity) {
      d3.selectAll(myClass)
        .transition()
        .duration(500)
        .style("opacity", opacity);
    }

    function setMapOpacity(value) {
      d3.selectAll(".mapboxgl-canvas")
        .transition()
        .duration(500)
        .style("opacity", value);
      d3.selectAll(".mapboxgl-control-container")
        .transition()
        .duration(500)
        .style("opacity", value);
    }

    function showMap() {
      setMapOpacity(1);
    }

    function hideMap() {
      setMapOpacity(0.1);
    }


    // initialize the scrollama
    var scroller = scrollama();

    // scrollama event handlers
    function handleStepEnter(response) {
      // response = { element, direction, index }
      console.log(response);
      // add to color to current step
      response.element.classList.add('active');
      if (response.element.attributes['step-num'].value === '12') {
        map.setPaintProperty('strainWaves', 'fill-opacity', 0.4)
      };
      if (response.direction === 'down') {
        if (response.element.attributes['step-num'].value === '2') {
          map.fitBounds(chapters['section1'], {
            speed: 0.7
          });
          //map.flyTo(chapters['section1']);
          initData(landers_before_url, before, "landers-before", [2.5, 8], [0, 1500], 1500); //range [0,4000] when not debugging
        };
        if (response.element.attributes['step-num'].value === '3') {
          initData(landers_mainshock_url, mainshock, "landers-mainshock", [2.5, 8], [0, 15000], 700, d3.easeElastic,
            1000);
        }
        if (response.element.attributes['step-num'].value === '4') {
          initData(landers_aftershocks_url, aftershock, "landers-aftershocks", [2.5, 8], [0, 700]);
        }
        if (response.element.attributes['step-num'].value === '5') {
          initData(landers_triggered_url, trigger, "landers-triggered", [2.5, 8], [0, 1500]); //range [0,4000] when not debugging
        }
        if (response.element.attributes['step-num'].value === '6') {
          hideMap();
          hideEl(".landers-aftershocks,.landers-mainshock");
          initChart(landers_before_url, landers_triggered_url);
        }
        if (response.element.attributes['step-num'].value === '7') {
          initChartHighlight(landers_before_url, landers_triggered_url);
        }
        if (response.element.attributes['step-num'].value === '8') {
          map.fitBounds(chapters['welcome'], {
            speed: 0.7
          });
        }
        if (response.element.attributes['step-num'].value === '9') {
          initData(sumatra_before_url, before, "sumatra-before", [2.5, 8], [0, 1500], 200); //range [0,4000] when not debugging
        };
        if (response.element.attributes['step-num'].value === '10') {
          initData(sumatra_mainshock_url, mainshock, "sumatra-mainshock", [2.5, 8], [0, 15000], 700, d3.easeElastic,
            1000); //range [0,4000] when not debugging
        };
        if (response.element.attributes['step-num'].value === '11') {
          initData(sumatra_triggered_url, trigger, "sumatra-triggered", [2.5, 8], [0, 1500]); //range [0,4000] when not debugging
        };
        if (response.element.attributes['step-num'].value === '13') {
          hideEl(".sumatra-before,.sumatra-mainshock,.sumatra-triggered");
          hideMap();
          initBars(bars_url);
        };
        if (response.element.attributes['step-num'].value === '14') {
          initBarsHighlight(bars_url);
        };
        if (response.element.attributes['step-num'].value === '17') {
          hideEl(".oita-triggered,.oita-mainshock");
          //hideArcs(arcsLayer);
          map.fitBounds(chapters['section3'], {
            speed: 0.7
          });
          initPoints(hokkaido_mainshock_url, mainshockHokkaido, "hokkaido-mainshock", [2.5, 8], [0, 4000], 2000, d3.easeElastic,
            1000); //range [0,4000] when not debugging
        };
        if (response.element.attributes['step-num'].value === '18') {
          initPoints(hokkaido_triggered_url, triggeredHokkaido, "hokkaido-triggered", [2.5, 8], [0, 4000], 2000, d3.easeElastic,
            1000); //range [0,4000] when not debugging
          strainArrows();
        };

      };
      if (response.direction === 'up') {
        //response.element.classList.remove('active');
        if (response.element.attributes['step-num'].value === '1') {
          map.fitBounds(chapters['welcome'], {
            speed: 0.7
          });
        }
        if (response.element.attributes['step-num'].value === '5') {
          showMap();
          eraseData(".chart-axis,.mainshock-line,.chart-label,.myArrow");
          exitChart(landers_before_url, landers_triggered_url);
          showEl(".landers-aftershocks,.landers-mainshock", 0.7);
          map.fitBounds(chapters['section1'], {
            speed: 0.7
          });
        }
        if (response.element.attributes['step-num'].value === '6') {
          exitChartHighlight(landers_before_url, landers_triggered_url);
          //showEl(".chart-axis,.mainshock-line,.landers-before,.landers-triggered,.myArrow,.chart-label");
        }
        if (response.element.attributes['step-num'].value === '7') {
          hideMap();
          showEl(".chart-axis,.mainshock-line,.landers-before,.landers-triggered,.myArrow,.chart-label");
          initChartBackwards(landers_before_url, landers_triggered_url);
        }
        if (response.element.attributes['step-num'].value === '12') {
          map.fitBounds(chapters['welcome'], {
            speed: 0.7
          })
          //eraseData(".bar-chart,.bar-axis,.globe,.mainshockDummy,.strain-wave,.deadzone")
          showMap();
          showEl(".sumatra-before", 0.3);
          showEl(".sumatra-mainshock,.sumatra-triggered", 0.7)
        };
        if (response.element.attributes['step-num'].value === '13') {
          reverseHighlightBars();
        };
        if (response.element.attributes['step-num'].value === '14') {
          initRedrawCircles(bars_url);
          showEl(".bar-chart,.bar-axis,.globe,.mainshockDummy,.strain-wave,.deadzone,.bar-label,.bar-arrow")
          hideMap();
        };

      }
    };

    function handleStepExit(response) {
      // response = { element, direction, index }
      console.log(response);
      // remove color from current step
      if (response.element.attributes['step-num'].value === '12') {
        map.setPaintProperty('strainWaves', 'fill-opacity', 0)
      };
      if (response.direction === 'down') {
        if (response.element.attributes['step-num'].value === '2') {
          fadeData(".landers-before");

        }
        if (response.element.attributes['step-num'].value === '4') {
          fadeData(".landers-aftershocks");

        }
        if (response.element.attributes['step-num'].value === '5') {
          fadeData(".landers-triggered");

        }
        if (response.element.attributes['step-num'].value === '6') {
          //showMap();
          //hideEl(".chart-axis,.mainshock-line,.landers-before,.landers-triggered,.chart-label,.myArrow");
        }
        if (response.element.attributes['step-num'].value === '7') {
          hideEl(".chart-axis,.mainshock-line,.landers-before,.landers-triggered,.myArrow,.chart-label");
          showMap();
        }
        if (response.element.attributes['step-num'].value === '9') {
          fadeData(".sumatra-before");
        };
        if (response.element.attributes['step-num'].value === '14') {
          eraseData(".mainshockDummy,.bar-axis");
          hideEl(".bar-chart,.bar-axis,.globe,.mainshockDummy,.strain-wave,.deadzone,.bar-label,.bar-arrow")
          showMap();
        };


      };
      if (response.direction === 'up') {
        if (response.element.attributes['step-num'].value === '2') {
          eraseData(".landers-before");

        };
        if (response.element.attributes['step-num'].value === '3') {
          eraseData(".landers-mainshock");

        }
        if (response.element.attributes['step-num'].value === '4') {
          eraseData(".landers-aftershocks");

        }
        if (response.element.attributes['step-num'].value === '5') {
          eraseData(".landers-triggered");

        }
        if (response.element.attributes['step-num'].value === '9') {
          eraseData(".sumatra-before");
        };
        if (response.element.attributes['step-num'].value === '10') {
          eraseData(".sumatra-mainshock");
        };
        if (response.element.attributes['step-num'].value === '11') {
          eraseData(".sumatra-triggered");
        };
        if (response.element.attributes['step-num'].value === '13') {
          eraseData(".bar-chart,.bar-axis,.globe,.mainshockDummy,.strain-wave,.deadzone,.bar-label,.bar-arrow");
        };

        if (response.element.attributes['step-num'].value === '17') {
          eraseData(".hokkaido-mainshock");
        };
        if (response.element.attributes['step-num'].value === '18') {
          eraseData(".hokkaido-triggered");
          eraseData("path.squiggle");
        };
      }
    }

    function init() {
      // 1. setup the scroller with the bare-bones options
      // 		this will also initialize trigger observations
      // 2. bind scrollama event handlers (this can be chained like below)
      scroller.setup({
          step: '.step',
          debug: false,
          offset: 0.5
        })
        .onStepEnter(handleStepEnter)
        .onStepExit(handleStepExit);

      // 3. setup resize event
      window.addEventListener('resize', scroller.resize);
    }

    // kick things off
    init();
    // } else {
    //   d3.select("#intro").remove();
    //   d3.select("#footer").remove();
    //   d3.select(".main").remove();
    //   d3.select("body")
    //     .append("div")
    //     .attr("class", "mobile")
    //     .html(
    //       "This page is not optimized for small screens, please visit it on a desktop screen (ideally 1400px) for the best viewing experience. Thank you."
    //     );
    //
    // }
  </script>
</body>

</html>
